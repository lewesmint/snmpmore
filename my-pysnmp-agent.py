#!/usr/bin/env python3
"""
SNMP agent using pysnmp that exposes scalars and tables as defined in MY-AGENT-MIB.
Listens on UDP port 10161 (non-privileged) and responds to SNMP queries.
"""

import threading
import asyncio
import time
import logging
from typing import Any, Tuple
from pysnmp.entity import engine, config
from pysnmp.carrier.asyncio.dgram import udp
from pysnmp.smi import builder
from pysnmp.entity.rfc3413 import cmdrsp, context
from pyasn1.type.univ import OctetString, Integer
from pysnmp.proto.api import v2c
from pysnmp.hlapi.v3arch.asyncio import (
    SnmpEngine, CommunityData, UdpTransportTarget,
    ContextData, NotificationType, send_notification
)
from pysnmp.smi.rfc1902 import ObjectIdentity

# Import SNMP data types
Counter32 = v2c.Counter32
Counter64 = v2c.Counter64
Gauge32 = v2c.Gauge32
TimeTicks = v2c.TimeTicks
IpAddress = v2c.IpAddress
Unsigned32 = v2c.Unsigned32
Integer32 = v2c.Integer32

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')


class SNMPAgent:
    """SNMP Agent that serves enterprise MIB data."""

    def __init__(self, host: str = '127.0.0.1', port: int = 10161) -> None:
        """Initialize the SNMP agent.

        Args:
            host: IP address to bind to
            port: UDP port to listen on (default 10161 for non-root)
        """
        self.host = host
        self.port = port
        self.snmpEngine = engine.SnmpEngine()
        self.mibBuilder = self.snmpEngine.get_mib_builder()

        # Add MIB sources
        self.mibBuilder.add_mib_sources(builder.DirMibSource('./mibs'))

        # Import MIB classes from SNMPv2-SMI
        (self.MibScalar,
         self.MibScalarInstance,
         self.MibTable,
         self.MibTableRow,
         self.MibTableColumn) = self.mibBuilder.import_symbols(
            'SNMPv2-SMI',
            'MibScalar',
            'MibScalarInstance',
            'MibTable',
            'MibTableRow',
            'MibTableColumn'
        )

        # Counter for dynamic scalar
        self.counter = 0
        self.counter_lock = threading.Lock()

        # Start time for TimeTicks
        self.start_time = time.time()

        # Table data
        self.table_rows = [
            [1, 'sensor_a', 25, 'ok'],
            [2, 'sensor_b', 30, 'ok'],
            [3, 'sensor_c', 45, 'warning'],
        ]

        self._setup_transport()
        self._setup_community()
        self._setup_responders()
        self._register_mib_objects()

    def _setup_transport(self) -> None:
        """Configure UDP transport."""
        config.add_transport(
            self.snmpEngine,
            udp.DOMAIN_NAME,
            udp.UdpTransport().open_server_mode((self.host, self.port))
        )

    def _setup_community(self) -> None:
        """Configure SNMPv2c community."""
        config.add_v1_system(self.snmpEngine, 'my-area', 'public')

        # Allow full access to enterprise subtree
        config.add_vacm_user(
            self.snmpEngine, 2, 'my-area', 'noAuthNoPriv',
            (1, 3, 6, 1, 4, 1, 99999)
        )

    def _setup_responders(self) -> None:
        """Setup SNMP command responders."""
        snmpContext = context.SnmpContext(self.snmpEngine)
        cmdrsp.GetCommandResponder(self.snmpEngine, snmpContext)
        cmdrsp.NextCommandResponder(self.snmpEngine, snmpContext)
        cmdrsp.BulkCommandResponder(self.snmpEngine, snmpContext)
        cmdrsp.SetCommandResponder(self.snmpEngine, snmpContext)

    def _get_counter(self, *args: Any) -> Integer:
        """Dynamic counter that increments on each GET."""
        with self.counter_lock:
            self.counter += 1
            return Integer(self.counter)

    def _register_mib_objects(self) -> None:
        """Register all MIB objects (scalars and table) using JSON."""
        import json
        # Load MIB behavior from JSON (generated by mib_to_json.py)
        with open('mock-behavior/MY-AGENT-MIB_behavior.json') as f:
            mib_json = json.load(f)

        # Map type names to pysnmp classes
        type_map = {
            'DisplayString': OctetString,
            'Integer32': Integer32,
            'Counter32': Counter32,
            'Counter64': Counter64,
            'Gauge32': Gauge32,
            'TimeTicks': TimeTicks,
            'IpAddress': IpAddress,
            'Unsigned32': Unsigned32,
            'OctetString': OctetString,
            'Integer': Integer,
        }

        # Register scalars
        # List of MibScalarInstance (runtime only); use Any for type checking
        from typing import Any
        scalar_symbols: list[Any] = []
        for name, info in mib_json.items():
            if info['type'] in type_map and isinstance(info['oid'], list) and len(info['oid']) == 8:
                pysnmp_type = type_map[info['type']]
                scalar_oid = tuple(info['oid'])
                # Use initial value if present, else default
                initial = info.get('initial')
                if initial is not None:
                    value = pysnmp_type(initial)
                else:
                    # Provide sensible defaults
                    if pysnmp_type is OctetString:
                        value = OctetString('default')
                    elif pysnmp_type is Integer32 or pysnmp_type is Integer:
                        value = pysnmp_type(0)
                    elif pysnmp_type is Counter32 or pysnmp_type is Counter64 or pysnmp_type is Gauge32 or pysnmp_type is Unsigned32:
                        value = pysnmp_type(0)
                    elif pysnmp_type is IpAddress:
                        value = IpAddress('127.0.0.1')
                    elif pysnmp_type is TimeTicks:
                        value = TimeTicks(0)
                    else:
                        value = pysnmp_type()
                scalar_symbols.append(self.MibScalar(scalar_oid, pysnmp_type()))
                scalar_symbols.append(self.MibScalarInstance(scalar_oid, (0,), value))

        self.mibBuilder.export_symbols('__MY_MIB', *scalar_symbols)

        # Register table structure
        table_info = {k: v for k, v in mib_json.items() if k.startswith('myTable')}
        if table_info:
            # Table, Entry, Columns
            myTable = self.MibTable(tuple(table_info['myTable']['oid']))
            myTableEntry = self.MibTableRow(tuple(table_info['myTableEntry']['oid'])).setIndexNames((0, '__MY_MIB', 'myTableIndex'))
            myTableIndex = self.MibTableColumn(tuple(table_info['myTableIndex']['oid']), Integer())
            myTableName = self.MibTableColumn(tuple(table_info['myTableName']['oid']), OctetString())
            myTableValue = self.MibTableColumn(tuple(table_info['myTableValue']['oid']), Integer())
            myTableStatus = self.MibTableColumn(tuple(table_info['myTableStatus']['oid']), OctetString())
            self.mibBuilder.export_symbols(
                '__MY_MIB',
                myTable=myTable,
                myTableEntry=myTableEntry,
                myTableIndex=myTableIndex,
                myTableName=myTableName,
                myTableValue=myTableValue,
                myTableStatus=myTableStatus,
            )

            # Now populate the table with data using MIB instrumentation
            snmpContext = context.SnmpContext(self.snmpEngine)
            mibInstrumentation = snmpContext.get_mib_instrum()
            (myTableEntry, myTableIndex, myTableName,
             myTableValue, myTableStatus) = self.mibBuilder.importSymbols(
                '__MY_MIB', 'myTableEntry', 'myTableIndex', 'myTableName',
                'myTableValue', 'myTableStatus'
            )
            for row in self.table_rows:
                idx, name, value, status = row
                rowInstanceId = myTableEntry.getInstIdFromIndices(idx)
                mibInstrumentation.write_variables(
                    (myTableIndex.name + rowInstanceId, idx),
                    (myTableName.name + rowInstanceId, name),
                    (myTableValue.name + rowInstanceId, value),
                    (myTableStatus.name + rowInstanceId, status),
                )

    def run(self) -> None:
        """Run the SNMP agent (blocking)."""
        print(f'SNMP agent running on {self.host}:{self.port}')
        print(f'Community: public')
        print(f'Enterprise OID: .1.3.6.1.4.1.99999')
        print(f'Try: snmpwalk -v2c -c public {self.host}:{self.port} .1.3.6.1.4.1.99999')
        print('Press Ctrl+C to stop')

        self.snmpEngine.transport_dispatcher.job_started(1)
        try:
            # For pysnmp v7 with asyncio, we need to run the event loop
            asyncio.get_event_loop().run_forever()
        except KeyboardInterrupt:
            print('\nShutting down agent')
        finally:
            self.snmpEngine.transport_dispatcher.close_dispatcher()

    def stop(self) -> None:
        """Stop the SNMP agent."""
        self.snmpEngine.transport_dispatcher.close_dispatcher()

    async def send_trap_async(self, trap_dest: Tuple[str, int], oid: Tuple[int, ...],
                              value: Any, trap_type: str = 'trap') -> None:
        """Send an SNMP trap or inform notification.

        Args:
            trap_dest: Tuple of (host, port) for trap destination
            oid: OID tuple for the trap variable binding
            value: Value to send with the trap
            trap_type: 'trap' or 'inform'
        """
        logger = logging.getLogger(__name__)
        try:
            # Create a notification type with the OID and value
            result = await send_notification(
                SnmpEngine(),
                CommunityData('public'),
                await UdpTransportTarget.create(trap_dest),
                ContextData(),
                trap_type,
                NotificationType(ObjectIdentity(1, 3, 6, 1, 6, 3, 1, 1, 5, 1)).add_var_binds((oid, value))
            )

            errorIndication = result[0]
            if errorIndication:
                logger.error(f'Trap send error: {errorIndication}')
            else:
                logger.info(f'Trap sent to {trap_dest} for OID {oid} with value {value}')
        except Exception as e:
            logger.error(f'Exception sending trap: {e}')

    def send_trap(self, trap_dest: Tuple[str, int], oid: Tuple[int, ...],
                  value: Any, trap_type: str = 'trap') -> None:
        """Send an SNMP trap synchronously (wrapper for async method).

        Args:
            trap_dest: Tuple of (host, port) for trap destination
            oid: OID tuple for the trap variable binding
            value: Value to send with the trap
            trap_type: 'trap' or 'inform'
        """
        asyncio.run(self.send_trap_async(trap_dest, oid, value, trap_type))


def main() -> None:
    """Main entry point."""
    agent = SNMPAgent()
    agent.run()


if __name__ == "__main__":
    main()
